//Package linescanner is a Go package which reads a line to the end of the line,
// not including the end of line characters in the token(line).
package linescanner

import (
	"bufio"
	"io"
	"sync"
)

//LineScanner is a scanner/lexical analyzer that reads a line from
//an io.Reader.
//The end of line characters \n or \r\n is not included in the line (token).
//You should continously loop in until the Scan() method returns true, or
//the LineScanner has an error. Read the error via the Err() method, which never
//returns io.EOF.
//When the Scan() method returns true a result is available until Scan returns
//true again.
//The result can be read via the Text(), or Bytes() methods.
//
//WARNING!: LineScanner does not limit the amount of memory that can be used
//to buffer a line, so wrap your io.Reader in a io.LimitedReader to do
//that. Then use the wrapped io.Reader (the io.LimitedReader) as the io.Reader
//argument to the New() or NewSize() functions.
//
//A LineScanner, which is initialized like this:
//
//		&linescanner.LineScanner{}
//
//... will not work correctly.
//Any issue using LineScanner like this will be closed, because it is concidered
//incorrect use of the LineScanner type.
type LineScanner struct {
	mutex     sync.Mutex
	r         *bufio.Reader
	token     []byte
	buf       []byte
	err       error
	readCount uint
	_         struct{}
}

// Err returns the first non-io.EOF error that was encountered by the LineScanner.
func (ls *LineScanner) Err() error {
	ls.mutex.Lock()
	defer ls.mutex.Unlock()

	if ls.err == io.EOF {
		return nil
	}
	return ls.err
}

// Bytes returns the most recent token generated by a call to Scan.
// The underlying array may point to data that will be overwritten
// by a subsequent call to Scan. It does no allocation.
func (ls *LineScanner) Bytes() []byte {
	ls.mutex.Lock()
	defer ls.mutex.Unlock()

	ls.readCount += 1
	return ls.token
}

// Text returns the most recent token generated by a call to Scan
// as a newly allocated string holding its bytes.
func (ls *LineScanner) Text() string {
	ls.mutex.Lock()
	defer ls.mutex.Unlock()

	ls.readCount += 1
	return string(ls.token)
}

func (ls *LineScanner) ReadCount() uint {
	ls.mutex.Lock()
	defer ls.mutex.Unlock()

	return ls.readCount
}
