
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/larsth/linescanner/linescanner.go (68.4%)</option>
				
				<option value="file1">github.com/larsth/linescanner/new.go (100.0%)</option>
				
				<option value="file2">github.com/larsth/linescanner/scan.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >//Package linescanner is a Go package which reads a line to the end of the line,
// not including the end of line characters in the token(line).
package linescanner

import (
        "bufio"
        "io"
        "sync"
)

//LineScanner is a scanner/lexical analyzer that reads a line from
//an io.Reader.
//The end of line characters \n or \r\n is not included in the line (token).
//You should continously loop in until the Scan() method returns true, or
//the LineScanner has an error. Read the error via the Err() method, which never
//returns io.EOF.
//When the Scan() method returns true a result is available until Scan returns
//true again.
//The result can be read via the Text(), or Bytes() methods.
//
//WARNING!: LineScanner does not limit the amount of memory that can be used
//to buffer a line, so wrap your io.Reader in a io.LimitedReader to do
//that. Then use the wrapped io.Reader (the io.LimitedReader) as the io.Reader
//argument to the New() or NewSize() functions.
//
//A LineScanner, which is initialized like this:
//
//                &amp;linescanner.LineScanner{}
//
//... will not work correctly.
//Any issue using LineScanner like this will be closed, because it is concidered
//incorrect use of the LineScanner type.
type LineScanner struct {
        mutex     sync.Mutex
        r         *bufio.Reader
        token     []byte
        buf       []byte
        err       error
        readCount uint
        hasEof bool
}

//HasEof returns wether or not the error is a io.EOF
func (ls *LineScanner) HasEof() bool <span class="cov0" title="0">{
        ls.mutex.Lock()
        defer ls.mutex.Unlock()
        
        return ls.hasEof
}</span>

// Err returns the first non-io.EOF error that was encountered by the LineScanner.
func (ls *LineScanner) Err() error <span class="cov10" title="16">{
        ls.mutex.Lock()
        defer ls.mutex.Unlock()

        if ls.err == io.EOF </span><span class="cov3" title="2">{
                return nil
        }</span>
        <span class="cov9" title="14">return ls.err</span>
}

// Bytes returns the most recent token generated by a call to Scan.
// The underlying array may point to data that will be overwritten
// by a subsequent call to Scan. It does no allocation.
func (ls *LineScanner) Bytes() []byte <span class="cov1" title="1">{
        ls.mutex.Lock()
        defer ls.mutex.Unlock()

        ls.readCount += 1
        return ls.token
}</span>

// Text returns the most recent token generated by a call to Scan
// as a newly allocated string holding its bytes.
func (ls *LineScanner) Text() string <span class="cov1" title="1">{
        ls.mutex.Lock()
        defer ls.mutex.Unlock()

        ls.readCount += 1
        return string(ls.token)
}</span>

func (ls *LineScanner) ReadCount() uint <span class="cov0" title="0">{
        ls.mutex.Lock()
        defer ls.mutex.Unlock()

        return ls.readCount
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package linescanner

import (
        "bufio"
        "errors"
        "io"
        "os"
)

var (
        //ErrNilIoReader is an error that tells the calling function that it is
        //using an io.Reader, which is nil
        ErrNilIoReader = errors.New("Nil io.Reader")

        //ErrReaderCapacityLessThanOne is an error that tells the calling
        //function that it is using a bufio.Reader capacity less than the
        //bufio.Reader minimum capacity, which is 16 (according to the source code
        //for the bufio.Reader.NewSize function).
        ErrReaderCapacityLessThanOne = errors.New("Reader capacity &lt; 16")

        //ErrTokenCapacityLessThanOne is an error that tells the calling
        //function that it is using a token capacity &lt; 1
        ErrTokenCapacityLessThanOne = errors.New("Token capacity &lt; 1")

        //ErrBufferCapacityLessThanOne is an error that tells the calling
        //function that it is using a buffer capacity &lt; 1
        ErrBufferCapacityLessThanOne = errors.New("Buffer capacity &lt; 1")
)

//NewSize creates a LineScanner and returns a pointer to it, if the provided
//io.Redader is not nil, if the readerCapacity is &gt;= 16, if the token capacity
// is &gt;= 1, and if te buffer capacity is &gt;= 1.
//If the conditions are met, then the returned error is nil.
//If the conditions are not met a nil *LineScanner pointer and an error != nil
//are returned.
func NewSize(r io.Reader, readerCapacity int, tokenCapacity int, bufferCapacity int) (ls *LineScanner, err error) <span class="cov10" title="16">{
        if r == nil </span><span class="cov3" title="2">{
                return nil, ErrNilIoReader
        }</span>
        <span class="cov9" title="14">if readerCapacity &lt; 16 </span><span class="cov1" title="1">{
                return nil, ErrReaderCapacityLessThanOne
        }</span>
        <span class="cov9" title="13">if tokenCapacity &lt; 1 </span><span class="cov1" title="1">{
                return nil, ErrTokenCapacityLessThanOne
        }</span>
        <span class="cov9" title="12">if bufferCapacity &lt; 1 </span><span class="cov1" title="1">{
                return nil, ErrBufferCapacityLessThanOne
        }</span>

        <span class="cov8" title="11">ls = new(LineScanner)
        ls.r = bufio.NewReaderSize(r, readerCapacity)
        ls.token = make([]byte, 0, tokenCapacity)
        ls.buf = make([]byte, 0, bufferCapacity)
        ls.err = nil

        return ls, nil</span>
}

//New creates a LineScanner and returns a pointer to it, if the provided
//io.Reader is not nil. If the provided io.Reader is not nil a nil error is also
//returned.
//If the io.Reader is nil, then a nil *Linescanner, and the ErrNilIoReader error
//are returned.
//All capacities (reader, token and buffer) will be set to os.Getpagesize,
//which will usually return 4096 (=a page is 4 KiB).
func New(r io.Reader) (ls *LineScanner, err error) <span class="cov7" title="7">{
        pageSize := os.Getpagesize()
        return NewSize(r, pageSize, pageSize, pageSize)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package linescanner

import "io"

//Scan reads a line, and returns true when a complete line had been found.
//If Scan did't find the end of line characters ('\n' or '\r\n'), and Scan
//returns false.
//Any previous token (line), and error can be read as long as Scan is returning
// false.
//A token is read via the Bytes() and Text methods, and the error is read via
//the Err() method.
//Scan supports reading sequential lines, but no indication or error is given
//if the input ends without a final line end.
func (ls *LineScanner) Scan() (hasToken bool) <span class="cov10" title="14">{
        var (
                line     []byte
                isPrefix bool
                err      error
        )

        ls.mutex.Lock()
        defer ls.mutex.Unlock()

        if ls.r == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov9" title="13">line, isPrefix, err = ls.r.ReadLine()
        //From the documentation about bufio.Reader.ReadLine:
        //ReadLine tries to return a single line, not including the end-of-line
        //bytes.
        //The text returned from ReadLine does not include the line end ("\r\n" or
        // "\n").
        //If the line was too long for the buffer then isPrefix is set and the
        //beginning of the line is returned.
        //The rest of the line will be returned from future calls.
        //isPrefix will be false when returning the last fragment of the line.
        //The returned buffer is only valid until the next call to ReadLine.
        //ReadLine either returns a non-nil line or it returns an error, never both.
        //No indication or error is given if the input ends without a final line end.

        hasToken = false
        if line != nil </span><span class="cov9" title="12">{
                ls.err = nil
                if isPrefix == false </span><span class="cov7" title="7">{
                        hasToken = true
                        ls.readCount = uint(0)
                        //clear the token slice:
                        ls.token = ls.token[0:0:cap(ls.token)]
                        //Append the buffer slice, then the line slice, to the token slice:
                        ls.token = append(ls.token, ls.buf...)
                        ls.token = append(ls.token, line...)
                        //clear the buffer slice:
                        ls.buf = ls.buf[0:0:cap(ls.buf)]
                }</span><span class="cov6" title="5"> else {
                        //Append the line slice to the buffer slice:
                        ls.buf = append(ls.buf, line...)
                }</span>
        }
        <span class="cov9" title="13">if err != nil </span><span class="cov1" title="1">{
                ls.err = err
        }</span>
        <span class="cov9" title="13">ls.hasEof = (err == io.EOF)
        return</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
